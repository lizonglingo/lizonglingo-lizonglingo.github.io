<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Li Duo</title>
    <link>https://lizonglingo.github.io/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Li Duo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 08 Jun 2020 18:05:43 +0800</lastBuildDate><atom:link href="https://lizonglingo.github.io/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在二叉树中使用递归解决问题</title>
      <link>https://lizonglingo.github.io/p/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 08 Jun 2020 18:05:43 +0800</pubDate>
      
      <guid>https://lizonglingo.github.io/p/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/</guid>
      <description>整理自leetcode 树结点定义如下： Definition for a binary tree node. struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; 二叉树的最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节</description>
    </item>
    
    <item>
      <title>链式存储二叉树的遍历</title>
      <link>https://lizonglingo.github.io/p/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <pubDate>Fri, 29 May 2020 16:27:12 +0800</pubDate>
      
      <guid>https://lizonglingo.github.io/p/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <description>先序遍历，中序遍历，后序遍历以及层次遍历。 使用递归、队列。 整理自Leetcode。 说明 使用到的树结点类型为： struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; 先序遍历</description>
    </item>
    
    <item>
      <title>leetcode链表初等整理</title>
      <link>https://lizonglingo.github.io/p/leetcode%E9%93%BE%E8%A1%A8%E5%88%9D%E7%AD%89%E6%95%B4%E7%90%86/</link>
      <pubDate>Mon, 25 May 2020 20:39:37 +0800</pubDate>
      
      <guid>https://lizonglingo.github.io/p/leetcode%E9%93%BE%E8%A1%A8%E5%88%9D%E7%AD%89%E6%95%B4%E7%90%86/</guid>
      <description>力扣关于链表这部分基础算法还是较为简单和基础的 没有特殊说明的情况下，链表节点类型为： struct ListNode { int val; struct ListNode *next; }; 同时，需要注意，默认的头指针head-</description>
    </item>
    
    <item>
      <title>leetcode字符串初等整理</title>
      <link>https://lizonglingo.github.io/p/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9D%E7%AD%89%E6%95%B4%E7%90%86/</link>
      <pubDate>Wed, 20 May 2020 21:35:30 +0800</pubDate>
      
      <guid>https://lizonglingo.github.io/p/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9D%E7%AD%89%E6%95%B4%E7%90%86/</guid>
      <description>反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入</description>
    </item>
    
    <item>
      <title>leetcode数组初等整理</title>
      <link>https://lizonglingo.github.io/p/leetcode%E6%95%B0%E7%BB%84%E5%88%9D%E7%AD%89%E6%95%B4%E7%90%86/</link>
      <pubDate>Mon, 11 May 2020 19:48:37 +0800</pubDate>
      
      <guid>https://lizonglingo.github.io/p/leetcode%E6%95%B0%E7%BB%84%E5%88%9D%E7%AD%89%E6%95%B4%E7%90%86/</guid>
      <description>好久没有更新了，最近开始做了些leetcode上的算法，刚把数组基础部分做完，整理一下，全部用的C 删除排序数组中的重复项 给定一个排序数组，你</description>
    </item>
    
    <item>
      <title>leetcode线性问题合辑（数组、链表、栈、队列）</title>
      <link>https://lizonglingo.github.io/p/leetcode%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98%E5%90%88%E8%BE%91%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%A0%88%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 22 Feb 2020 21:39:19 +0800</pubDate>
      
      <guid>https://lizonglingo.github.io/p/leetcode%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98%E5%90%88%E8%BE%91%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%A0%88%E9%98%9F%E5%88%97/</guid>
      <description>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/ 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载</description>
    </item>
    
    <item>
      <title>常见的排序算法总结</title>
      <link>https://lizonglingo.github.io/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 21 Nov 2019 19:36:24 +0800</pubDate>
      
      <guid>https://lizonglingo.github.io/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>整理常用的排序算法，主要包括： 选择排序 冒泡排序 归并排序 快速排序 插入排序 堆排序 策略以及时间开销 排序算法 基于的思想 时间开销 选择排序 蛮力法 O(n^2) 冒泡排</description>
    </item>
    
    <item>
      <title>用不同算法解决0/1背包问题</title>
      <link>https://lizonglingo.github.io/p/%E7%94%A8%E4%B8%8D%E5%90%8C%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B30/1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 21 Nov 2019 14:34:04 +0800</pubDate>
      
      <guid>https://lizonglingo.github.io/p/%E7%94%A8%E4%B8%8D%E5%90%8C%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B30/1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>0/1背包问题是算法中很经典的问题，具体内容题目内容不再赘述，需要请自行搜索.. 蛮力法 思想 蛮力法的基本思想就是遍历 时间复杂度 Ω(2^n) 代码</description>
    </item>
    
  </channel>
</rss>
